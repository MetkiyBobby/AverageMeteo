#! python3
# Программа для подсчета среднесуточных и среднемесячных значений и не только
# метеовеличин по данным АМК

import math # испорт модуля math для расчета среднего значения
import pyperclip # импорт модуля pyperclip для копирования из буфера обмена


def timing(data):
    """ Функция принимает многострочный блок и разбивает его на список строк,
    возвращая новый список"""
    time_dividedList = data.split('\n')
    return time_dividedList

def timeFiltering(data):
    """Функция принимает список содержащий строки со всеми сроками измерений
    и возвращает список содержащий только сроки измерений в начале часа"""
    time_filtredList = []
    for i in data:
        if '00' in i[14:16]: # [14:16] - срез содержащий значение минут
                             # если True элемент добавляется в новый список
            time_filtredList.append(i)
    return time_filtredList

def calendarIntoMeteo(data):
    """Функция принимает список измерений с датами по календарным суткам
    и возвращает список с датами по метеорологическим суткам (следующие
    метеорологические сутки начинаются в 15:00 ВСВ)"""
    lastDayOfMonth = ('01-31', '02-28', '02-29', '03-31', '04-30', '05-31',
                      '06-30', '07-31', '08-31', '09-30', '10-31', '11-30',
                      '12-31') # список содержащий последние даты месяцев
    listOfTerms = list(range(15, 24)) # список содержащий часы, которые
                                      # относятся к следующим суткам
    meteo_list = [] # список содержащий даты по метеорологическим суткам
    for i in data:  # перебираются все элементы исходного списка
        if int(i[11:13]) in listOfTerms:
            # если срез текущего элемента, содержащий значение часа
            # есть в списке относится к срокам переносимым на следующие
            # сутки
            calendarDay = int(i[8:10]) # срез содержащий значение
                                       # календарного дня
            calendarMonth = int(i[5:7])# срез содержащий значение
                                       # календарного месяца
            meteoDay = str(calendarDay + 1) # значение метеорологических
                                            # суток
            meteoMonth = str(calendarMonth + 1) # значение метеорологического
                                                # месяца
            if calendarDay < 9: 
                meteo_list.append(i[:8] + '0' + meteoDay + i[10:])
            elif i[5:10] in lastDayOfMonth: # если срез содержащий значение
                                            # календарного месяца содержится
                                            # в списке последних дат месяцев
                if calendarMonth < 9:
                    meteo_list.append(i[:5] + '0' + meteoMonth + '-01' +
                                    i[10:])
                else:
                    meteo_list.append(i[:5] + meteoMonth + '-01' + i[10:])
            else:
                meteo_list.append(i[:8] + meteoDay + i[10:])
        else:
            meteo_list.append(i)
               
    return meteo_list

def dataByDay(data):
    """Функция принимает список измерений и возвращает словарь в качестве
    ключей в котором используются даты, а в качестве значений списки из
    строк содержащих данные измерений произведенных в этот день."""
    days = {}
    for i in data: # перебираются все элементы исходного списка,
                   # т.е. данные всех наблюдений с интервалов 1 час
       
        thisDayList = []# во время каждой итерации создается список,
                        # который должен содержать данные наблюдений
                        # произведенные за все часы одних суток (т.е.,
                        # если ряд полный, 24 строки с данными) 
        for j in data:  # во время каждой итерации первого цикла for
                        # производится еще один перебор всех элементов
                        # исходного списка.
            if i[0:10] in j[0:10]: # с помощью среза из элемента первого
                                   # цикла for берется дата и проверяется
                                   # совпадает ли она с датой элемента из
                                   # вложенного цикла for и если True:
                ind = (j.index('\t') + 1) # находится индекс первого знака
                                          # табуляции элемента вложенного
                                          # цикла for, чтобы отделить часть
                                          # строки содержащую дату
                thisDayList.append(j[ind:]) # список содержащий данные наб-
                                            # людений за этот день пополня-
                                            # ется срезом элемента вложенн-
                                            # ого цикла for без даты
            days.setdefault(i[0:10], thisDayList) # так как в исходном цикле
                                                  # for дата повторяется
                                                  # много раз в словарь эта
                                                  # дата добавляется только
                                                  # первый раз, как и соот-
                                                  # ветствующий список
                                                  # thisDayList
    return(days)


def convertToFloat(data):
    """Функция принимает словарь возвращаемый функцией dataByDay
    и возвращает такой же словарь, но данные измерений метеоэементов
    в нем переконвертированы в вещественные числа"""
    floatMeteoQuantities = {} # словарь содержащий значения метеоэлементов
                              # в виде вещественных чисел
    for key, value in data.items(): # перебираются все ключи и значения
                                    # исходного словаря
        floatValue = [] # список содержащий списки списков метеоэлементов в
                        # в виде вещественных чисел 
        for term in value: # перебираются все элементы value
            i = term.split('\t') # каждый элемент разбивается на список
                                 # внутри которого элементами служат
                                 # значения метеовеличин
            floatTerm = [] # список содержащий значения метеовеличин
                           # в виде вещественных чисел
            for j in i: # перебираются все значения метеоэлементов
                if j == 'None\r' or j == 'None': 
                    f = 9999.0 # если значение отсутствует ему присваивается
                               # заведомо нереалистичная величина 9999.0
                else:
                    f = float(j) # иначе значение конвертируется
                floatTerm.append(f)
            floatValue.append(floatTerm)
        floatMeteoQuantities.setdefault(key, floatValue)

    return floatMeteoQuantities



              
def dailyAverage(data):
    """Функция принимает словарь возвращаемый функцией convertToFloat
    и выводит на экран средние арифметические значения выбранной
    метеовеличины за каждый день"""
    ind = choiceOfMeteoQuantity() # переменная принимает значение от 0 до 6
                                  # и используется в качестве индекса
    meteoQuantities = ('направления ветра', 'скорости ветра',
                       'скорости ветра при порывах', 'точки росы',
                       'относительной влажности воздуха',
                       'температуры воздуха', 'атмосферного давления')
    print()
    print(('Среднесуточные значения ' + meteoQuantities[ind]).center(70,'-'))
    for key, value in data.items(): # перебираются все ключи и значения
                                    # исходного словаря
        valuesOfMeteoQuantities = []# список содержащий значения
                                    # метеовеличины для текущей даты
        for i in value: # перебираются все элементы value
            if i[ind] != 9999.0: # если метеоэлемент с индексом ind
                                 # не равен 9999.0
                valuesOfMeteoQuantities.append(i[ind])
        dayAverage = round((math.fsum(valuesOfMeteoQuantities) 
                            / len(valuesOfMeteoQuantities)),1)
            # вычисляется среднее значение мтеовеличины исходя из значений
        # содержащихся в списке valuesOfMeteoQuantities
        if len(valuesOfMeteoQuantities) < 24:
            print(key + ';' + (str(dayAverage)).rjust(10, ' ') +
                  '; (Неполные данные. Расчет произведен по ' +
                  str(len(valuesOfMeteoQuantities)) + ' значениям)')
        else:
            print(key + ';' + (str(dayAverage)).rjust(10, ' '))
    print()
    print()


    

def mainMenu():
    while True:
        print(('РАСЧЕТ СРЕДНЕСУТОЧНЫХ ЗНАЧЕНИЙ МЕТЕОВЕЛИЧИН ПО ДАННЫМ АМК').center(70, '='))
        print()
        print('Скопируйте ряд наблюдений в буфер обмена. \n(Для этого' +
              ' откройте текстовый документ Яршево или Коробово, \n' +
              'затем выберите пункт меню Правка - Выделить все, \n' +
              'затем Правка - Копировать)')
        print('Теперь закройте или сверните открытый ранее текстовый документ')
        print()
        print('Теперь необходимо работать в этом окне (с черным фоном)')
        print("Наберите на клавиатуре слово 'расчет' для начала расчета \n"
              "или слово 'выход', чтобы завершить работу с программой\n"
              + "затем нажмите клавишу 'ENTER'")
        userChoice = (input()).lower()
        if userChoice.startswith('р'):
            calculation()
        elif userChoice.startswith('в'):
            break
        else:
            continue

def choiceOfMeteoQuantity():
    """Функция предлагает выбрать метеовеличину среднее значение которой
    хочет получить пользователь"""
    meteoQuantity = 10 # переменной присваивается неиспользуемое значение
    while not(meteoQuantity in list(range(0, 7))):
        print()
        print('Выберите метеовеличину из списка (наберите на клавиатуре \n'
              + 'соответствующую цифру и нажмите клавишу \'ENTER\'):')
        print('направление ветра(0), скорость ветра(1), порыв ветра(2),\n'+
              'точка росы(3), относительная влажность воздуха(4),\n' +
              'температура воздуха(5), атмосферное давление (6)')
        
        try:
            meteoQuantity = int(input())
        except ValueError:
            print('Необходимо ввести цифру от 0 до 6')
            continue
    return int(meteoQuantity)

def calculation():
    initialData = str(pyperclip.paste()) # программа принимает данные
                                     # из буфера обмена
    step1 = timing(initialData)
    step2 = timeFiltering(step1)
    step3 = calendarIntoMeteo(step2)
    step4 = dataByDay(step3)
    step5 = convertToFloat(step4)
    step6 = dailyAverage(step5)
    
mainMenu()       









        


    
